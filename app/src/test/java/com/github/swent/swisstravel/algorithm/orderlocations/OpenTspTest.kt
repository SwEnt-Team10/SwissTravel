package com.github.swent.swisstravel.algorithm.orderlocations

import kotlin.random.Random
import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Test

/** Tests generated by ChatGPT. */
class OpenTspTest {

  private val openTsp = OpenTsp()

  @Test
  fun `openTsp computes correct order for small asymmetric graph`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 10.0, 15.0, 40.0),
            doubleArrayOf(5.0, 0.0, 9.0, 10.0),
            doubleArrayOf(6.0, 13.0, 0.0, 12.0),
            doubleArrayOf(8.0, 8.0, 9.0, 0.0))

    val result = openTsp.openTsp(dist, start = 0, end = 3)

    // Route must start and end correctly
    assertEquals(0, result.first())
    assertEquals(3, result.last())

    // All nodes should appear exactly once
    assertEquals(dist.size, result.distinct().size)

    // The expected route is the minimal one
    val expected = listOf(0, 1, 2, 3)
    assertEquals(expected, result)
  }

  @Test
  fun `openTsp handles asymmetric costs`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 3.0, 9.0, 8.0),
            doubleArrayOf(2.0, 0.0, 6.0, 4.0),
            doubleArrayOf(1.0, 7.0, 0.0, 2.0),
            doubleArrayOf(6.0, 3.0, 5.0, 0.0))

    val route = openTsp.openTsp(dist, start = 0, end = 3)

    assertEquals(0, route.first())
    assertEquals(3, route.last())
    assertEquals(dist.size, route.distinct().size)

    // Calculate total distance of result to check plausibility
    val total = route.zipWithNext { a, b -> dist[a][b] }.sum()
    val alternative = listOf(0, 2, 1, 3).zipWithNext { a, b -> dist[a][b] }.sum()

    // Heuristic should not perform worse than obvious alternative
    assertTrue(total <= alternative)
  }

  @Test
  fun `openTsp works with only start and end`() {
    val dist = arrayOf(doubleArrayOf(0.0, 10.0), doubleArrayOf(5.0, 0.0))

    val result = openTsp.openTsp(dist, start = 0, end = 1)
    assertEquals(listOf(0, 1), result)
  }

  @Test
  fun `openTsp produces valid permutation`() {
    val random = Random(42L)
    val dist =
        Array(5) { i ->
          DoubleArray(5) { j -> if (i == j) 0.0 else (random.nextInt(10) + 1).toDouble() }
        }

    val route = openTsp.openTsp(dist, start = 0, end = 4)

    assertEquals(0, route.first())
    assertEquals(4, route.last())
    assertEquals(5, route.distinct().size)
  }

  @Test
  fun `openTsp with simple case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 10.0, 10.0),
            doubleArrayOf(1.0, 0.0, 2.0, 10.0),
            doubleArrayOf(10.0, 2.0, 0.0, 3.0),
            doubleArrayOf(10.0, 10.0, 3.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 3)
    assertEquals(listOf(0, 1, 2, 3), route)
  }

  @Test
  fun `openTsp with another simple case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 10.0, 1.0, 10.0),
            doubleArrayOf(10.0, 0.0, 10.0, 2.0),
            doubleArrayOf(1.0, 10.0, 0.0, 3.0),
            doubleArrayOf(10.0, 2.0, 3.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 1)
    assertEquals(listOf(0, 2, 3, 1), route)
  }

  @Test
  fun `openTsp with a more complex case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 5.0, 6.0, 7.0),
            doubleArrayOf(1.0, 0.0, 2.0, 8.0, 9.0),
            doubleArrayOf(5.0, 2.0, 0.0, 3.0, 10.0),
            doubleArrayOf(6.0, 8.0, 3.0, 0.0, 4.0),
            doubleArrayOf(7.0, 9.0, 10.0, 4.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 4)
    assertEquals(listOf(0, 1, 2, 3, 4), route)
  }

  @Test
  fun `twoOpt does not change an optimal route`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 5.0, 6.0, 7.0),
            doubleArrayOf(1.0, 0.0, 2.0, 8.0, 9.0),
            doubleArrayOf(5.0, 2.0, 0.0, 3.0, 10.0),
            doubleArrayOf(6.0, 8.0, 3.0, 0.0, 4.0),
            doubleArrayOf(7.0, 9.0, 10.0, 4.0, 0.0))
    val route = listOf(0, 1, 2, 3, 4)
    val result = openTsp.twoOpt(route, dist)
    assertEquals(route, result)
  }

  @Test
  fun `openTsp with same start and end location`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 10.0, 1.0),
            doubleArrayOf(1.0, 0.0, 1.0, 10.0),
            doubleArrayOf(10.0, 1.0, 0.0, 1.0),
            doubleArrayOf(1.0, 10.0, 1.0, 0.0))

    // Start and end at location 0
    val route = openTsp.openTsp(dist, 0, 0)

    // The route should start and end at the same node
    assertEquals("Route should start at 0", 0, route.first())
    assertEquals("Route should end at 0", 0, route.last())

    // All nodes should be visited, plus the return to the start
    assertEquals("Route should visit all 4 nodes and return", 5, route.size)
    assertEquals("Route should contain 4 unique nodes", 4, route.distinct().size)

    // The optimal tour is 0 -> 1 -> 2 -> 3 -> 0
    val expectedRoute = listOf(0, 1, 2, 3, 0)
    assertEquals(expectedRoute, route)
  }
}
