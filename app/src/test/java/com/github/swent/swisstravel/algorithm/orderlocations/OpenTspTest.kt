package com.github.swent.swisstravel.algorithm.orderlocations

import org.junit.Assert.assertEquals
import org.junit.Assert.assertTrue
import org.junit.Test

/** Tests generated by ChatGPT. */
class OpenTspTest {

  private val openTsp = OpenTsp()

  @Test
  fun `openTsp computes correct order for small asymmetric graph`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 10.0, 15.0, 40.0),
            doubleArrayOf(5.0, 0.0, 9.0, 10.0),
            doubleArrayOf(6.0, 13.0, 0.0, 12.0),
            doubleArrayOf(8.0, 8.0, 9.0, 0.0))

    val result = openTsp.openTsp(dist, start = 0, end = 3)

    // Route must start and end correctly
    assertEquals(0, result.first())
    assertEquals(3, result.last())

    // All nodes should appear exactly once
    assertEquals(dist.size, result.distinct().size)

    // The expected route is the minimal one
    val expected = listOf(0, 1, 2, 3)
    assertEquals(expected, result)
  }

  @Test
  fun `openTsp handles asymmetric costs`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 3.0, 9.0, 8.0),
            doubleArrayOf(2.0, 0.0, 6.0, 4.0),
            doubleArrayOf(1.0, 7.0, 0.0, 2.0),
            doubleArrayOf(6.0, 3.0, 5.0, 0.0))

    val route = openTsp.openTsp(dist, start = 0, end = 3)

    assertEquals(0, route.first())
    assertEquals(3, route.last())
    assertEquals(dist.size, route.distinct().size)

    // Calculate total distance of result to check plausibility
    val total = route.zipWithNext { a, b -> dist[a][b] }.sum()
    val alternative = listOf(0, 2, 1, 3).zipWithNext { a, b -> dist[a][b] }.sum()

    // Heuristic should not perform worse than obvious alternative
    assertTrue(total <= alternative)
  }

  @Test
  fun `openTsp works with only start and end`() {
    val dist = arrayOf(doubleArrayOf(0.0, 10.0), doubleArrayOf(5.0, 0.0))

    val result = openTsp.openTsp(dist, start = 0, end = 1)
    assertEquals(listOf(0, 1), result)
  }

  @Test
  fun `openTsp produces valid permutation`() {
    val dist =
        Array(5) { i -> DoubleArray(5) { j -> if (i == j) 0.0 else (1..10).random().toDouble() } }

    val route = openTsp.openTsp(dist, start = 0, end = 4)

    assertEquals(0, route.first())
    assertEquals(4, route.last())
    assertEquals(5, route.distinct().size)
  }

  @Test
  fun `openTsp with simple case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 10.0, 10.0),
            doubleArrayOf(1.0, 0.0, 2.0, 10.0),
            doubleArrayOf(10.0, 2.0, 0.0, 3.0),
            doubleArrayOf(10.0, 10.0, 3.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 3)
    assertEquals(listOf(0, 1, 2, 3), route)
  }

  @Test
  fun `openTsp with another simple case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 10.0, 1.0, 10.0),
            doubleArrayOf(10.0, 0.0, 10.0, 2.0),
            doubleArrayOf(1.0, 10.0, 0.0, 3.0),
            doubleArrayOf(10.0, 2.0, 3.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 1)
    assertEquals(listOf(0, 2, 3, 1), route)
  }

  @Test
  fun `openTsp with a more complex case`() {
    val dist =
        arrayOf(
            doubleArrayOf(0.0, 1.0, 5.0, 6.0, 7.0),
            doubleArrayOf(1.0, 0.0, 2.0, 8.0, 9.0),
            doubleArrayOf(5.0, 2.0, 0.0, 3.0, 10.0),
            doubleArrayOf(6.0, 8.0, 3.0, 0.0, 4.0),
            doubleArrayOf(7.0, 9.0, 10.0, 4.0, 0.0))
    val route = openTsp.openTsp(dist, 0, 4)
    assertEquals(listOf(0, 1, 2, 3, 4), route)
  }
}
